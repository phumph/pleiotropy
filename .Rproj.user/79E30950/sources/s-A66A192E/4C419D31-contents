#! /usr/bin/Rscript
# script to calculate fitness clusters for each target environment for haploids and diploids
# last updated: 2018-OCT-18 by PTH

# load fitness data:
fit1 <- read.csv(here('data/dBFA2_hBFA1_with_adapt_11APR2018.csv'))

# load adapted and mut+ information
#htsum2 <- read.csv(file = here("data/haps_fit_and_mut_2018-OCT-16.csv")) # haploids
htsum2 <- read.csv(file = here("data/haps_fit_and_mut_2019-MAY-09.csv")) # haploids
# dtsum2 <- read.csv(file = here("data/dips_fit_and_mut_2018-OCT-16.csv")) # diploids
dtsum2 <- read.csv(file = here("data/dips_fit_and_mut_2019-APR-11.csv")) # diploids

# start with haps: grab fitness data from all focal barcodes (adapteds, non-autodips)
hf1 <- fit1[fit1$Diverse.BC %in% unique(paste0(htsum2$Diverse.BC[htsum2$adapted==1])),]
hf1 <- droplevels(hf1[hf1$bfa.env != 'X48Hr',])
hap_envs <- c('GlyEtOH','FLC4','CLM')

# # unique barcodes that fit criteria of being non-autodiploid and adapted:
# length(unique(hf1$Diverse.BC))
# length(unique(paste0(htsum2$Diverse.BC[htsum2$adapted==1])))
# # perfect; got 100% of them.

# now for diploids:
df1 <- fit1[fit1$Diverse.BC %in% unique(paste0(dtsum2$Diverse.BC[dtsum2$adapted==1])),]
df1 <- droplevels(df1[!df1$bfa.env %in% c('X48Hr','X37C_Stan'),])
dip_envs <- c('FLC4','CLM','21C','37C','GlyEtOH','02M_NaCl','pH7_3')

# reduce fitness values by factor of 8 in the FLC4 and CLM environments for diploids:
df1[df1$bfa.env %in% c('FLC4','CLM'),'iva.s'] <- df1[df1$bfa.env %in% c('FLC4','CLM'),'iva.s'] / 8


# now: work through each source environment and cluster, given a list of focal environments:
calc_gap <- function(x,y,K){
  # sum up the log difference across all reps:
  gap <- log(x) - log(y)
  gap_mean <- mean(log(x), na.rm = T) - log(y)
  gap_sd <- sd(gap, na.rm = T)
  return(data.frame(k = K, gap_mean, gap_sd))
}

cluster_by_env <- function(df, envs, kmax = 20, R = 200, ploid = '1N', step = 'find_k', k_df){
  
  require(reshape2)
  require(dplyr)
  require(ggpubr)
  #require(flipCluster)
  
  k_plots <- list()
  df_res <- list()
  
  for(i in seq_along(envs)){
    # subset input df to target source env
    df2 <- df[df$source %in% envs[i] & df$ploidy == ploid,]
    kmax <- 20
    
    # truncate kmax:
    if (kmax > length(unique(df2$Diverse.BC))){
      kmax <- length(unique(df2$Diverse.BC))
    }
    
    # cast:
    df3 <- reshape2::dcast(df2, Diverse.BC + source ~ bfa.env, value.var = 'iva.s')
    #df4 <- as.matrix(df3[,-c(1:2)])
    row.names(df3) = df3$Diverse.BC
    
    # get rid of Inf and NA values in fitness vectors
    df3[df3==Inf] <- NA
    df4 <- df3[complete.cases(df3),]
    
    #Ks <- lapply(as.list(c(1:kmax)), function(x) KMeans(df4, centers = x, output = 'Means table', missing = 'Use partial data'))
    Ks <- lapply(as.list(c(1:kmax)), function(x) kmeans(as.matrix(df4[,-c(1:2)]), centers = x, iter.max = 100)) 
    ss <- do.call(rbind,lapply(Ks, function(x) data.frame(WSS = x$tot.withinss, TSS = x$totss, k = length(unique(x$cluster)))))
    
    # do routine if add_k is specified:
    if (step == 'add_k'){
      # find correct k from input k_df
      the_k <- dplyr::filter(k_df, ploidy == ploid, sources == envs[i])$k
      if (!is.na(the_k)){
        df4$cluster <- Ks[[the_k]]$cluster
        # return df with cluster ID represented as new col:
      } else {
        df4$cluster <- 1
      }
      df_res[[i]] <- df4 # append modified input data.frame
    } else if (step == 'find_k') { 
      # ss_p1 <- ggplot(ss, aes(x = k, y = WSS)) + geom_point() + geom_line() + theme_pth1() +
      #   ggtitle(unique(df3$source))
      # 
      # now perform k-means clustering on permuted datasets to calculat gap statistic in order to select k
      R <- 200
      Nss <- NULL
      for (r in 1:R){
        # permute input matrix; sample without replacement:
        df5 <- apply(df4,2,function(x) sample(x, length(x), replace = T))
        NKs <- lapply(as.list(c(1:kmax)), function(x) kmeans(df4[,-c(1:2)], centers = x, iter.max = 100)) 
        Nss <- rbind(Nss,do.call(rbind,lapply(NKs, function(x) data.frame(WSS = x$tot.withinss, TSS = x$totss, k = length(unique(x$cluster)), R = r))))
      }
      # now plot distribution for each k:
      #Nss <- Nss[-1,]
      ss_p2 <- ggplot() + geom_line(data = Nss, aes(x = k, y = WSS, group = factor(R)), alpha = 0.2, col = "gray40") + theme_pth1() +
        geom_line(data = ss, aes(x = k, y = WSS), col = "midnightblue") + scale_x_continuous(limits = c(1,kmax), breaks = seq(1,kmax,1)) +
        ggtitle(unique(df3$source))
      
      # compute gap statistic:
      # it's the expected value of the difference between the withinSS of the null at a given k and the observed:
      # need to run through each R:
      Nss  <- merge(Nss,ss,by='k',all.x = T, sort = F) %>% dplyr::arrange(k,R)
      Nss2 <- split(Nss,Nss$k)
      gaps <- do.call(rbind,lapply(Nss2, function(q) calc_gap(q$WSS.x,unique(q$WSS.y),K = unique(q$k))))
      
      gap_plot <- ggplot(gaps, aes(x = k, y = gap_mean, ymin = gap_mean - gap_sd, ymax = gap_mean + gap_sd)) + geom_linerange() +
        geom_point() + ggtitle(unique(df3$source)) +
        geom_line() +
        theme_pth1()
      
      #k_plots[[i]] <- ss_p2
      k_plots[[i]] <- ggarrange(plotlist = list(ss_p2,gap_plot), ncol = 2, align = 'hv')
      ggsave(k_plots[[i]], filename = paste0(here("plt_figs/cluster_plots/cluster_plot_"),unique(df3$source),'_',ploid,'.pdf'), width = 6, height = 3)
      
      # this just doesn't really look good!
      # # calculate slope
      # WSSd <- rep(NA,kmax)
      # WSSd[1] <- with(ss,WSS[1])
      # for(k in 2:kmax){
      #   WSSd[k] <- (ss$WSS[k-1] - ss$WSS[k]) #/ ss$WSS[k-1]
      # }
      # 
      # now calculate derivative and look for positions of maximum deviation
      # this might be a little tricky.. and perhaps a little wonky.
      # this will provide some heuristic way to define best k.
      # for now, just spit out the plots and do it by hand; this will work for now.
      # will have to make input vector for k for each ploidy/source, but that's fine.
    } # end of else
  } # end of for loop
  # decide what to return:
  if (step == 'find_k') {
    return(k_plots)
  } else if (step == 'add_k'){
    return(do.call(rbind,df_res))
  }
}

HK1 <- cluster_by_env(df = hf1, envs = hap_envs, R = 200, kmax = 20, ploid = '1N', step = 'find_k')
DK1 <- cluster_by_env(df = df1, envs = dip_envs, R = 200, kmax = 20, ploid = '2N', step = 'find_k')

#for diploids, need to cluster WITHOUT CLM and FLC4 BFA environments. These measurements are TOTALLY SCREWY.
# I will define clusters based on all the rest, then visualize those clusters WITH those environments added back.
# ths fitness values will be scaled down by factor of 10 to actually be report-able on the same plot as the others.



# look at plots and decide which k to use for now:
# decided based on heuristic that takes the lowest k for which the change in gap score is >= 1df but where k > 3 (since this is just too low...)
# create input k:
k_df <- rbind(data.frame(ploidy = '1N', sources = hap_envs, ks = c(6,7,6)),
              data.frame(ploidy = '2N', sources = dip_envs, ks = c(9,9,4,7,16,9,4))
)

# now, walk through and cluster; attach cluster ID to input BC:
HK2 <- cluster_by_env(df = hf1, envs = hap_envs, ploid = '1N', step = 'add_k', k_df = k_df)
DK2 <- cluster_by_env(df = df1, envs = dip_envs, ploid = '2N', step = 'add_k', k_df = k_df)

# generate plots for each source!
# first add back in the has_mutation flag:
HK2 <- droplevels(merge(HK2, htsum2[,names(htsum2) %in% c('Diverse.BC','mutation')], by = 'Diverse.BC', all.x = TRUE))
DK2 <- droplevels(merge(DK2, dtsum2[,names(dtsum2) %in% c('Diverse.BC','mutation')], by = 'Diverse.BC', all.x = TRUE))

# now split and send to plotter function that displays fitness traces for all and those with mutations:
x <- split(HK2,HK2$source)[[1]]

fit_plot_with_mut <- function(x, ploidy){
  # step 1: generate full plot with fitness clusters
  x2 <- reshape2::melt(x, id.vars = c('Diverse.BC','source','cluster','mutation'), value.name = 'fitness', variable.name = 'bfa.env')
  x2$cluster <- factor(x2$cluster)
  
  # define range of data:
  #range(x2$fitness)
  # produce first plot:
  require(scales)
  
  # define palette for n clusters: 
  the_cols <- hue_pal()(max(as.numeric(x2$cluster)))
  the_range <- range(x2$fitness)
  
  if(the_range[1] < -0.2){
    the_range[1] <- -0.2
  }
  
  pc_all <- ggplot(x2, aes(x = bfa.env, y = fitness, group = Diverse.BC)) +
    theme_pth1() + geom_hline(yintercept = 0, lwd = 0.5) +
    geom_line(aes(col = cluster), alpha = 0.4) +
    ggtitle(paste0(x2$source[1], ' (n = ',length(unique(x2$Diverse.BC)),' BCs)')) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
          legend.spacing.y = unit(0.2, 'cm')) +
    scale_y_continuous(limits = the_range, breaks = seq(-0.2,0.6,0.05)) +
    scale_color_manual(values = the_cols)
  
  # define new colors based on clusters present in resulting sub-df:
  all_col_hits <- sort(as.numeric(unique(x2$cluster)))
  mut_col_hits <- sort(as.numeric(unique(x2$cluster[x2$mutation==T])))
  mut_cols <- the_cols[mut_col_hits]
  
  pc_mut <- ggplot(x2[x2$mutation==T,], aes(x = bfa.env, y = fitness, group = Diverse.BC)) +
    theme_pth1() + geom_hline(yintercept = 0, lwd = 0.5) +
    geom_line(aes(col = cluster), alpha = 0.4) +
    ggtitle(paste0('(n = ',length(unique(x2$Diverse.BC[x2$mutation==T])),' BCs with mutation data)')) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
          legend.spacing.y = unit(0.2, 'cm')) +
    scale_y_continuous(limits = the_range, breaks = seq(-0.2,0.2,0.05)) +
    scale_color_manual(values = mut_cols)
  
  # now generate histogram of cluster abundances and make bar plot like the other types:
  muts <- data.frame(with(x2[x2$bfa.env == 'FLC4',], table(cluster,mutation)))
  names(muts) <- c('cluster','mutation','count')
  
  bar_mut <- ggplot() + geom_bar(data = muts, aes(x = cluster, y = count, fill = mutation), stat = 'identity', position = position_dodge(0.5), alpha = 0.5) +
    theme_pth1() + scale_fill_manual(values = c('gray40','dodgerblue'), name = 'has mutation data') +
    #theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
    ylab("number of unique BCs in cluster") + 
    xlab("cluster") + 
    ggtitle("") #+
    #scale_y_continuous(limits = c(-3,60), breaks = seq(0,60,10)) +
    #annotate(geom = "text", label = paste0(mut_t3$all_adapted), x = mut_t3$source, y = -2, size = 2)

  # put it all together:
  the_file_name <- paste0(here("plt_figs/fitplots_"),ploidy,'_',x2$source[1],'.pdf')
  ggarrange(plotlist = list(pc_all,pc_mut,bar_mut), ncol = 3, widths = c(1,1,0.75), align = 'hv', common.legend = T, legend = 'right') %>% 
    ggsave(filename = the_file_name, width = 8, height = 2.5)
  
}

lapply(split(HK2,HK2$source),function(x) fit_plot_with_mut(x, ploidy = '1N_v2'))
lapply(split(DK2,DK2$source),function(x) fit_plot_with_mut(x, ploidy = '2N_v2'))


#### MUTATION PATTERNS ####
# start with haploids
# first exclude cluster 1 from GlyEtOH:
HK2b <- HK2[!(HK2$source == 'GlyEtOH' & HK2$cluster == 1),] # 256 lineages, down from 275
HK2c <- HK2b[HK2b$mutation==T,] # 165 lineages

# next, bring in mutation information for these barcodes:
# re-import actual mutation data and grab target locus information:
hap_muts_pc <- read.table(here("data/mutations/mutations_final_filter_alpha.txt"),F,'\t')
hap_muts_ig <- read.table(here("data/mutations/mutations_IG_alpha.txt"),F,'\t')
hap_muts <- unique(rbind(hap_muts_pc[,c(1:2,12)],hap_muts_ig[,c(1:2,12)])) # 402 diploid genomes

# fix the way the barcodes are reported to jibe with fitness data:
hap_muts$Diverse.BC <- sapply(hap_muts$V2, function(x) unlist(strsplit(paste0(x),'_'))[1])
hap_muts <- hap_muts[,c(1,3,4)]
names(hap_muts) <- c('clone_id','locus','Diverse.BC')

# only keep barcodes which occur in fitness data:
hap_muts <- hap_muts[hap_muts$Diverse.BC %in% HK2c$Diverse.BC,]

# split on Diverse.BC and count up number of distinct mutations per BC
# generate list of loci per barcode, rbind, then dcast into matrix that can be sorted
# we will then cluster and spit out the corresponding 1/0 matrix
# which itself can be sorted by Hamming distance
hap_muts2 <- split(hap_muts, hap_muts$Diverse.BC)

# create function that generates counts per BC:
mut_counter <- function(x,locus='locus'){
  #return(data.frame(Diverse.BC = x$Diverse.BC, n_mutations = dim(muts)))
  # simply return the data.frame with all unique rows at BC level:
  unique(x[,names(x) %in% c('Diverse.BC',locus)])
}

mut_uniques <- do.call(rbind,lapply(hap_muts2,mut_counter))
# dcast this and sort by colSums
muts2 <- reshape2::dcast(mut_uniques, Diverse.BC ~ locus, fun.aggregate = length)
counts_muts <- sort(colSums(muts2[,-c(1)]))

# ditch all loci with only one hit across the dataset, just to keep plotting simple:
loci_to_ex <- names(counts_muts[counts_muts<2])

row.names(muts2) <- muts2$Diverse.BC
counts_BCs <- sort(rowSums(muts2[,-c(1)]))

# sort columns by sums:
muts2 <- muts2[,c('Diverse.BC',names(counts_muts))]
muts3 <- merge(muts2,HK2c[,names(HK2c) %in% c('Diverse.BC','source','cluster')], all.x = T)

# let's just plot clusters broken down by source and visualize the matrix of mutations:
muts4 <- reshape2::melt(muts3, id.vars = c('Diverse.BC','source','cluster'), variable.name = 'locus', value.name = 'hit')
muts4 <- droplevels(muts4[!muts4$locus %in% loci_to_ex,])
muts4$locus <- factor(muts4$locus, levels = rev(paste0(names(counts_muts))))

# also sort Diverse.BC by total number of mutations:
muts4$Diverse.BC <- factor(muts4$Diverse.BC, levels = rev(paste0(names(counts_BCs))))

plot_muts_by_cluster <- function(dat,ploidy){
  mutp1 <- ggplot(dat, aes(x = locus, y = Diverse.BC, fill = factor(hit))) + geom_tile() + 
    facet_grid(cluster ~ source, scales = 'free_y', space = 'free') + theme_pth1() + #nrow = length(unique(dat$cluster))
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          legend.position = 'none',
          panel.spacing = unit(0.1, "cm")) +
    scale_fill_manual(values = c('gray25','dodgerblue')) +
    ggtitle(dat$source[1])
  ggsave(mutp1, filename = paste0(here("plt_figs/"),'mut_dist_plot_',ploidy,'_',dat$source[1],'.pdf'), width = 5, height = 5)
}

plot_muts_by_cluster(muts4[muts4$source==unique(muts4$source)[1],], ploidy = '1N')
plot_muts_by_cluster(muts4[muts4$source==unique(muts4$source)[2],], ploidy = '1N')
plot_muts_by_cluster(muts4[muts4$source==unique(muts4$source)[3],], ploidy = '1N')


#### DIPLOIDS ####
## previous version of the analysis:

# do diploids for completeness:
dip_muts_pc <- read.table(here("data/mutations/mutations_final_filter_2N.txt"),F,'\t')
dip_muts_ig <- read.table(here("data/mutations/mutations_IG_2N.txt"),F,'\t')
dip_muts <- unique(rbind(dip_muts_pc[,c(1:2,12)],dip_muts_ig[,c(1:2,12)])) # 402 diploid genomes

# fix the way the barcodes are reported to jibe with fitness data:
dip_muts$Diverse.BC <- sapply(dip_muts$V2, function(x) unlist(strsplit(paste0(x),'_'))[1])
dip_muts <- dip_muts[,c(1,3,4)]
names(dip_muts) <- c('clone_id','locus','Diverse.BC')

DK2b <- DK2[DK2$mutation==T,] # 165 lineages
dip_muts <- dip_muts[dip_muts$Diverse.BC %in% DK2b$Diverse.BC,]

# split on Diverse.BC and count up number of distinct mutations per BC
dip_muts2 <- split(dip_muts, dip_muts$Diverse.BC)
dip_mut_uniques <- do.call(rbind,lapply(dip_muts2,mut_counter,locus='GENE'))

# dcast this and sort by colSums
dip_muts2 <- reshape2::dcast(dip_mut_uniques, Diverse.BC ~ locus, fun.aggregate = length)
dip_counts_muts <- sort(colSums(dip_muts2[,-c(1)]))

# ditch all loci with only one hit across the dataset, just to keep plotting simple:
dip_loci_to_ex <- names(dip_counts_muts[dip_counts_muts<2])

row.names(dip_muts2) <- dip_muts2$Diverse.BC
dip_counts_BCs <- sort(rowSums(dip_muts2[,-c(1)]))

# sort columns by sums:
dip_muts2 <- dip_muts2[,c('Diverse.BC',names(dip_counts_muts))]
dip_muts3 <- merge(dip_muts2,DK2b[,names(DK2b) %in% c('Diverse.BC','source','cluster')], all.x = T)

# let's just plot clusters broken down by source and visualize the matrix of mutations:
dip_muts4 <- reshape2::melt(dip_muts3, id.vars = c('Diverse.BC','source','cluster'), variable.name = 'locus', value.name = 'hit')
dip_muts4 <- droplevels(dip_muts4[!dip_muts4$locus %in% dip_loci_to_ex,])
dip_muts4$locus <- factor(dip_muts4$locus, levels = rev(paste0(names(dip_counts_muts))))

# also sort Diverse.BC by total number of mutations:
dip_muts4$Diverse.BC <- factor(dip_muts4$Diverse.BC, levels = rev(paste0(names(dip_counts_BCs))))

# export plots
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[1],], ploidy = '2N')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[2],], ploidy = '2N')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[3],], ploidy = '2N')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[4],], ploidy = '2N')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[5],], ploidy = '2N')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[6],], ploidy = '2N')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[7],], ploidy = '2N')
# end


#### diploid RE-ANALYSIS ####
# 2019-APR-11 by PTH
# using NEW mutation calls from Yuping

# do diploids for completeness:
# dip_muts_pc <- read.table(here("data/mutations/mutations_final_filter_2N.txt"),F,'\t')
# dip_muts_ig <- read.table(here("data/mutations/mutations_IG_2N.txt"),F,'\t')
# dip_muts <- unique(rbind(dip_muts_pc[,c(1:2,12)],dip_muts_ig[,c(1:2,12)])) # 402 diploid genomes


# load mutation data:
dip_muts <- read.csv(file=here("data/mutations/2019-APR-11/2019-APR-11_dip_files5.csv"))

DK2b <- DK2[DK2$mutation==T,] # 203 lineages
dip_muts <- dip_muts[dip_muts$Diverse.BC %in% DK2b$Diverse.BC,]

# split on Diverse.BC and count up number of distinct mutations per BC
dip_muts2 <- split(dip_muts, dip_muts$Diverse.BC)
dip_mut_uniques <- do.call(rbind,lapply(dip_muts2,mut_counter,locus='GENE'))

# dcast this and sort by colSums
dip_muts2 <- reshape2::dcast(dip_mut_uniques, Diverse.BC ~ GENE, fun.aggregate = length)
dip_counts_muts <- sort(colSums(dip_muts2[,-c(1)]))

# ditch all loci with only one hit across the dataset, just to keep plotting simple:
dip_loci_to_ex <- names(dip_counts_muts[dip_counts_muts<2])

row.names(dip_muts2) <- dip_muts2$Diverse.BC
dip_counts_BCs <- sort(rowSums(dip_muts2[,-c(1)]))

# sort columns by sums:
dip_muts2 <- dip_muts2[,c('Diverse.BC',names(dip_counts_muts))]
dip_muts3 <- merge(dip_muts2,DK2b[,names(DK2b) %in% c('Diverse.BC','source','cluster')], all.x = T)

# let's just plot clusters broken down by source and visualize the matrix of mutations:
dip_muts4 <- reshape2::melt(dip_muts3, id.vars = c('Diverse.BC','source','cluster'), variable.name = 'GENE', value.name = 'hit')

dplyr::group_by(dip_muts4, Diverse.BC) %>% summarise(tot_hits = sum(hit)) %>% arrange(tot_hits)

#dip_muts4 <- droplevels(dip_muts4[!dip_muts4$GENE %in% dip_loci_to_ex,])
dip_muts4$locus <- factor(dip_muts4$GENE, levels = rev(paste0(names(dip_counts_muts))))

# also sort Diverse.BC by total number of mutations:
dip_muts4$Diverse.BC <- factor(dip_muts4$Diverse.BC, levels = rev(paste0(names(dip_counts_BCs))))

# export plots
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[1],], ploidy = '2N_v2')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[2],], ploidy = '2N_v2')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[3],], ploidy = '2N_v2')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[4],], ploidy = '2N_v2')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[5],], ploidy = '2N_v2')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[6],], ploidy = '2N_v2')
plot_muts_by_cluster(dip_muts4[dip_muts4$source==unique(dip_muts4$source)[7],], ploidy = '2N_v2')

# other plots I want to make:

# 1. number of hits per BC
df1 <- data.frame(sums = rowSums(dip_muts2[,-c(1)]))
df1$Diverse.BC <- row.names(df1)
# add in Subpool.Environment
df2 <- merge(df1,unique(dip_muts4[,c('Diverse.BC','source')]),all.x=T,all.y=F)

gp1 <- ggplot(df2, aes(x = sums)) + geom_bar() + theme_pth1() + facet_wrap(~source)+
  scale_x_continuous(limits=c(0,12), breaks = c(1:12)) + xlab("N mutations per BC") +
  ylab("count")

ggsave(gp1,filename = here("plt_figs/2019-APR-11_n_muts_per_BC.pdf"),width=7,height=6)


# 2. number of hits per GENE:
gene_hit_counts <- sort(colSums(dip_muts3[,!names(dip_muts3) %in% c('Diverse.BC','source','cluster')]))
df3 <- data.frame(sums = gene_hit_counts)
df3$GENE <- row.names(df3)

gp2 <- ggplot(df3, aes(x = sums)) + geom_bar() + theme_pth1() +
  scale_x_continuous(limits=c(0,21), breaks = seq(0,20,2)) +
  #scale_y_continuous(limits=c(0,50), breaks = seq(0,50,10)) +
  xlab("N hits per gene") +
  ylab("count") 

ggsave(gp2,filename = here("plt_figs/2019-APR-11_n_hits_per_GENE.pdf"),width=3,height=2.5)
