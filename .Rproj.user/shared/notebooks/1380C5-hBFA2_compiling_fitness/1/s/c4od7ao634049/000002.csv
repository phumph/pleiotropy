"0","```r
# define global variables
PWD <- c(\"s_fits_v2/\")
ENVS <- c(\"02M_NaCl\",\"08M_NaCl\",\"21C\",\"CLM\",\"FLC4\",\"SC\",\"pH3_8\",\"pH7_3\",\"YPD\",\"GlyEtOH\")

## input counts file
COUNT_FILE <- read.csv('../data_PLT/data_hBFA2/hBFA2_bc_counts_cleaned.csv',T)
COUNT_FILE[,'Index'] <- c(1:length(COUNT_FILE[,1]))
source_env <- COUNT_FILE[,names(COUNT_FILE) %in% c('Index','Environment','Diverse.BC','Environment.BC')]

# import name of all fitness files to be worked on by the following routine
s_res_FILES <- gsub(PWD,'',Sys.glob(paste0(PWD,\"*s_res_full.csv\")))

# define results objects:
JDFE <- list() # will retain JDFE-style info
s_res_final <- data.frame() # will hold growing rows of fitness data

# run through routine for parsing fitness estimates for the current file s_file:
for (e in 1:length(ENVS)){
  
  env_hits <- s_res_FILES[grep(ENVS[e],s_res_FILES)]
  rep_vec <- c(\"R1\",\"R2\",\"R3\")
  s_files <- list()
  
  # load files matching current environment ENVS[e]
  for (f in env_hits) {
    s_files[[f]] <- read.csv(paste0(PWD,f))
  } 
  
  
  ### FITNESS PARSING ROUTINE FOR BFA ENVS WHERE NREPS == 1
  if (length(env_hits) == 1){
    # do single thing
    env_df <- data.frame(s_files[[1]], 
                         bfa_rep = unlist(strsplit(names(s_files[env_hits]), split = '_'))[unlist(strsplit(names(s_files[env_hits]), split = '_')) %in% rep_vec]
    )
    
    df_s.e <- dplyr::filter(env_df, t == unique(env_df[,'t'])[1],
                            run == max(env_df[,'run'])
    )
    
    # transform Index for mergine
    df_s.e[,'Index'] <- factor(df_s.e[,'Index'])
    # add source environment information from counts file; match to source_env
    
    df_s.e[,'s_bar_w'] <- df_s.e[,'s']
    df_s.e[,'sd_w'] <- df_s.e[,'s_se']
    
    # add lineage meta-data (BCs, source env)
    df_s.e6 <- merge(df_s.e, source_env, by = 'Index', sort = FALSE)
    
    # calculate AT% for concatenated BCs
    df_s.e6$FullBC <- paste0(df_s.e6$Diverse.BC,df_s.e6$Environment.BC)
    
    # calculate AT%
    df_s.e6$AT <- sapply(df_s.e6$FullBC, at.calc)
    
    # transform AT% to relative
    df_s.e6$ATz <- zscore(df_s.e6$AT)
    
  } else{
    # loop through to find reps; mutate; and 
    # env_df <- data.frame(s_files[env_hits[rep]], rep = 
    env_df <- data.frame(s_files[[env_hits[1]]], 
                         bfa_rep = unlist(strsplit(names(s_files[env_hits[1]]), split = '_'))[unlist(strsplit(names(s_files[env_hits[1]]), split = '_')) %in% rep_vec]
    )
    for (rep in 2:length(env_hits)){
      env_df <- rbind(
        env_df,
        data.frame(s_files[[env_hits[rep]]],
                   bfa_rep = unlist(strsplit(names(s_files[env_hits[rep]]), split = '_'))[unlist(strsplit(names(s_files[env_hits[rep]]), split = '_')) %in% rep_vec]
        ))
    }
    
    df_s.e <- dplyr::filter(env_df, t == unique(env_df[,'t'])[1],
                            run == max(env_df[,'run'])
    )
    
    df_s.e[,'Index'] <- factor(df_s.e[,'Index'])
    
    # now calculate:
    df_s.e2 <- dplyr::group_by(df_s.e, Index, add = FALSE)
    df_s.e2b <- as.data.frame(dplyr::summarise(df_s.e2, sum_w = sum(1/s_se)))
    
    # merge this back to initial df so I can perform the calculation:
    df_s.e3 <- merge(df_s.e, df_s.e2b, by = 'Index', sort = FALSE)
    
    df_s.e3[,'Index'] <- factor(df_s.e3[,'Index'])
    
    # calculate normalized weights:
    df_s.e3 <- dplyr::mutate(df_s.e3, w_i = ((1/s_se) / (sum_w)), sw_i = s*w_i)
    
    # now sum up sw_i to get weighted mean s:
    weighted_s <- dplyr::group_by(df_s.e3, Index) %>% dplyr::summarise(s_bar_w = sum(sw_i))
    
    # add this back to df_s.e3:
    df_s.e4 <- merge(df_s.e3, weighted_s, by = 'Index', sort = FALSE)
    
    # calculate weighted standard deviation:
    weighted_sd_s <- dplyr::group_by(df_s.e4, Index) %>% dplyr::summarise(sd_w = sqrt((sum((w_i) * (s - s_bar_w)^2) * length(env_hits))/(sum(w_i) * (length(env_hits)-1))))
    
    # finally, add back to full data.frame
    df_s.e5 <- merge(df_s.e4, weighted_sd_s, by = 'Index', sort = FALSE)
    
    # add source environment information from counts file; match to source_env
    df_s.e6 <- merge(df_s.e5, source_env, by = 'Index', sort = FALSE)
    
    # calculate AT% for concatenated BCs
    df_s.e6$FullBC <- paste0(df_s.e6$Diverse.BC,df_s.e6$Environment.BC)
    
    # calculate AT%
    df_s.e6$AT <- sapply(df_s.e6$FullBC, at.calc)
    
    # transform AT% to relative
    df_s.e6$ATz <- zscore(df_s.e6$AT)
    
  }
  
  ### PLOTTING ROUTING ###
  # need to have routine for number of reps for the environment:
  num.reps <- unique(df_s.e6[,'rep.x'])
  
  #system('mkdir s_dist_plots') # run this ONCE
  #system('mkdir s_rep_plots') # run this ONCE
  
  if (length(num.reps) == 1){
    # make single plots, not comparing between reps at all
    # look at distribution of s values with standard deviation applied:
    # df.tmp <- dplyr::filter(df_s.e6, s_bar_w > -0.5, bfa_rep == paste0(num.reps[1]))[,c('Index','s_bar_w','sd_w','Environment')] %>% dplyr::arrange(s_bar_w)
    # df.tmp[,'Index'] <- factor(df.tmp[,'Index'], levels = df.tmp[,'Index'])
    # 
    df.tmp <- dplyr::filter(df_s.e6, s > -0.6, s_bar_w > -0.6) %>% dplyr::arrange(s_bar_w)
    df.tmp[,'Index'] <- factor(df.tmp[,'Index'], levels = unique(df.tmp[,'Index']))
    
    ### FIRST PLOT: sorted fitness vector
    gp1 <- ggplot(df.tmp, aes(x = Index, y = s_bar_w, ymin = s_bar_w - sd_w, ymax = s_bar_w + sd_w)) + 
      geom_errorbar() + 
      geom_point(color = 'gray40') + 
      theme_bw() + 
      theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank()) + 
      geom_hline(yintercept = 0, col = \"red\", lty = \"dashed\") + 
      ggtitle(paste0(\"(A.) Sorted raw weighted s vector ± sigma_s: \",df_s.e6[1,'env.x'],\", rep \",num.reps[1])) + 
      xlab(\"BC\") + 
      ylab(\"s_bar\") + theme(plot.title = element_text(size=9, face = 'bold'))
    
    ### SECOND PLOT: fitness histogram
    gp2 <- ggplot(df.tmp, aes(x = s_bar_w)) + geom_histogram(bins = 200) + theme_bw() + xlab(\"weighted s\") +
      ggtitle(paste0(\"(B.) Histogram of sigma_s: \",df_s.e6[1,'env.x'],\", rep \",num.reps[1])) + theme(plot.title = element_text(size=9, face = 'bold'))
    
    ### THIRD PLOT: HISTOGRAM OF SIGMA
    gp3 <- ggplot(df.tmp, aes(x = sd_w)) + geom_histogram(bins = 200) + theme_bw() + xlab(\"sigma_s\") +
      ggtitle(paste0(\"(C.) Histogram of sigma_s: \",df_s.e6[1,'env.x'],\", rep \",num.reps[1])) + theme(plot.title = element_text(size=9, face = 'bold'))

    ### FOURTH PLOT: relationship between fitness estimate and error
    gp4 <- ggplot(df.tmp, aes(x = s_bar_w, y = sd_w, alpha = 0.2)) + geom_point() + theme_bw() +
      ggtitle(paste0(\"(D.) s_hat vs. sigma_s: \",df_s.e6[1,'env.x'],\", rep \",num.reps[1])) + theme(legend.position = 'none') +
      xlab(\"weighted s\") + ylab(\"sigma_s\") + theme(plot.title = element_text(size=9, face = 'bold'))

    ### FIFTH PLOT: relationship between AT bias and error
    gp5 <- ggplot(df.tmp, aes(x = AT, y = sd_w, alpha = 0.2, color = ATz)) + geom_point() + theme_bw() + theme(legend.position = 'none') +
      ggtitle(paste0(\"(E.) BC AT% vs. sigma_s: \",df_s.e6[1,'env.x'])) +
      xlab(\"AT% for BC1+BC2\") + ylab(\"sigma_s\") + theme(plot.title = element_text(size=9, face = 'bold')) +
      scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)

    pdf(file = paste0('s_dist_plots/s_dist_plots_',df_s.e6[1,'env.x'],'_rep_',num.reps[1],'.pdf'), width = 6, height = 8)
      grid.arrange(gp1,gp2,gp3,gp4,gp5,nrow = 3)
    dev.off()
    
    ### routine for parsing all data and writing env.tmp data file, to be merged with master_s_data
    
    
  } else { # if num.reps > 1, make different df.tmp and output plots depending on whether num.reps == 2 or num.reps == 3.
    
    # make new df.tmp irrespective of num.reps length
    df.tmp <- dplyr::filter(df_s.e6, s > -0.6, s_bar_w > -0.6) %>% dplyr::arrange(s_bar_w)
    df.tmp[,'Index'] <- factor(df.tmp[,'Index'], levels = unique(df.tmp[,'Index']))
    
    # produce standard plots like above; only difference: facet_wrap breaks apart by reps
    ### FIRST PLOT: sorted weighted fitness vector
    gp1 <- ggplot(df.tmp, aes(x = Index, y = s_bar_w, ymin = s_bar_w - sd_w, ymax = s_bar_w + sd_w)) + 
      geom_errorbar() + 
      geom_point(color = 'gray40') + 
      theme_bw() + 
      theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank()) + 
      geom_hline(yintercept = 0, col = \"red\", lty = \"dashed\") + 
      ggtitle(paste0(\"(A.) Sorted raw weighted s vector ± sigma_s: \",df_s.e6[1,'env.x'])) + 
      xlab(\"BC\") + 
      ylab(\"s_bar\") + theme(plot.title = element_text(size=9, face = 'bold'),
                            legend.position = 'none')
    
    ### SECOND PLOT: fitness histogram
    gp2 <- ggplot(df.tmp, aes(x = s_bar_w)) + geom_histogram(bins = 200) + theme_bw() + xlab(\"weighted s\") +
      ggtitle(paste0(\"(B.) Histogram of sigma_s: \",df_s.e6[1,'env.x'])) + theme(plot.title = element_text(size=9, face = 'bold'))
    
    ## THIRD PLOT: HISTOGRAM OF SIGMA
    gp3 <- ggplot(df.tmp, aes(x = sd_w)) + geom_histogram(bins = 200) + theme_bw() + xlab(\"sigma_s\") +
      ggtitle(paste0(\"(C.) Histogram of sigma_s: \",df_s.e6[1,'env.x'])) + theme(plot.title = element_text(size=9, face = 'bold'))
    
    ### FOURTH PLOT: relationship between fitness estimate and error
    gp4 <- ggplot(df.tmp, aes(x = s_bar_w, y = sd_w, alpha = 0.2)) + geom_point() + theme_bw() +
      ggtitle(paste0(\"(D.) s_hat vs. sigma_s: \",df_s.e6[1,'env.x'])) + 
      xlab(\"weighted s\") + ylab(\"sigma_s\") + theme(plot.title = element_text(size=9, face = 'bold'), legend.position = 'none') +
      scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)
    
    ### FIFTH PLOT: relationship between AT bias and error
    gp5 <- ggplot(df.tmp, aes(x = AT, y = sd_w, alpha = 0.2, color = ATz)) + geom_point() + theme_bw() + theme(legend.position = 'none') + 
      ggtitle(paste0(\"(E.) BC AT% vs. sigma_s: \",df_s.e6[1,'env.x'])) + 
      xlab(\"AT% for BC1+BC2\") + ylab(\"sigma_s\") + theme(plot.title = element_text(size=9, face = 'bold')) +
      scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)
    
    # produce cast data.frame for rep v rep plotting:
    dcast_s    <- dcast(df.tmp, formula = Index ~ rep.x, value.var = 's')
    dcast_s_se <- dcast(df.tmp, formula = Index ~ rep.x, value.var = 's_se')
    
    # combine dcast data.frames
    names(dcast_s)[2:length(names(dcast_s))] <- sapply(names(dcast_s)[2:length(names(dcast_s))],function(x) paste0(x,'.s'))
    names(dcast_s_se)[2:length(names(dcast_s_se))] <- sapply(names(dcast_s_se)[2:length(names(dcast_s_se))],function(x) paste0(x,'.s_se'))
    # merge to additional tmp df
    df.tmp2 <- merge(dcast_s,dcast_s_se,by = 'Index', sort= F)
    df.tmp3 <- merge(df.tmp2, df.tmp[,names(df.tmp) %in% c('Index','AT','ATz','sd_w','s_bar_w','Environment')], sort = FALSE)
    
    if (length(num.reps) == 2){
      # print above plots with width = 8;
      pdf(file = paste0('s_dist_plots/s_dist_plots_',df_s.e6[1,'env.x'],'.pdf'), width = 6, height = 8)
        grid.arrange(gp1,gp2,gp3,gp4,gp5,nrow = 3)
      dev.off()
      
      # need to only take complete cases as well as mask out rows with s < -0.3 in any rep.
      df.tmp3 <- df.tmp3[complete.cases(df.tmp3),]
      df.tmp4 <- dplyr::filter(df.tmp3)
      # produce Rep # vs. Rep # plot (no error bars)
      gp6 <- ggplot(df.tmp3[complete.cases(df.tmp3),], aes_string(x = names(df.tmp3)[2], y = names(df.tmp3)[3], col = 'ATz', alpha = '0.2')) + 
        geom_point() + theme_bw() + 
        geom_hline(yintercept = 0, col = \"gray60\") + geom_vline(xintercept = 0, col = \"black\") +
        geom_abline(slope = 1, intercept = 0, col = \"gray40\", lty = 3) + 
        theme(legend.position = \"none\") +
        scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)
      
      pdf(file = paste0('s_rep_plots/s_rep_',df_s.e6[1,'env.x'],'.pdf'), width = 5, height = 4)
        grid.arrange(gp6,nrow=1)
      dev.off()
      
    } else if(length(num.reps) == 3){
      # print above plots with width = 12;
      pdf(file = paste0('s_dist_plots/s_dist_plots_',df_s.e6[1,'env.x'],'.pdf'), width = 6, height = 8)
        grid.arrange(gp1,gp2,gp3,gp4,gp5,nrow = 3)
      dev.off()
      
      # plot all reps against each other and print as separate file
      gp6 <- ggplot(df.tmp3[complete.cases(df.tmp3),], aes_string(x = names(df.tmp3)[2],y = names(df.tmp3)[3], col = 'ATz', alpha = '0.2')) + 
        geom_point() + theme_bw() + 
        geom_hline(yintercept = 0, col = \"gray60\") + geom_vline(xintercept = 0, col = \"black\") +
        geom_abline(slope = 1, intercept = 0, col = \"gray40\", lty = 3) + 
        theme(legend.position = \"none\") +
        scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)
      
      gp7 <- ggplot(df.tmp3[complete.cases(df.tmp3),], aes_string(x = names(df.tmp3)[2],y = names(df.tmp3)[4], col = 'ATz', alpha = '0.2')) + 
        geom_point() + theme_bw() + 
        geom_hline(yintercept = 0, col = \"gray60\") + geom_vline(xintercept = 0, col = \"black\") +
        geom_abline(slope = 1, intercept = 0, col = \"gray40\", lty = 3) + 
        theme(legend.position = \"none\") +
        scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)
      
      gp8 <- ggplot(df.tmp3[complete.cases(df.tmp3),], aes_string(x = names(df.tmp3)[3],y = names(df.tmp3)[4], col = 'ATz', alpha = '0.2')) + 
        geom_point() + theme_bw() + 
        geom_hline(yintercept = 0, col = \"gray60\") + geom_vline(xintercept = 0, col = \"black\") +
        geom_abline(slope = 1, intercept = 0, col = \"gray40\", lty = 3) + 
        theme(legend.position = \"none\") +
        scale_color_gradient2(high = \"darkorange2\", low = \"dodgerblue\", mid = \"gray60\", midpoint = 0)
      
      pdf(file = paste0('s_rep_plots/s_rep_',df_s.e6[1,'env.x'],'.pdf'), width = 5, height = 12)
        grid.arrange(gp6,gp7,gp8,nrow=3)
      dev.off()
    }   
    
    ### DATA OUTPUT FOR length(num.reps) > 1:
    # columns:
    # Index, Diverse.BC, Environment.BC, Environment, ENVS[e]_rep[r].s, ENVS[e]_rep[r].s_se, ENVS[e].s_bar_w, ENVS[e].sd_w
    # plot two reps against each other and print as separate file
    dcast_s    <- dcast(df.tmp, formula = Index ~ rep.x, value.var = 's')
    dcast_s_se <- dcast(df.tmp, formula = Index ~ rep.x, value.var = 's_se')
    
    # combine dcast data.frames
    names(dcast_s)[2:length(names(dcast_s))] <- sapply(names(dcast_s)[2:length(names(dcast_s))],function(x) paste0(ENVS[e],'_',x,'.s'))
    names(dcast_s_se)[2:length(names(dcast_s_se))] <- sapply(names(dcast_s_se)[2:length(names(dcast_s_se))],function(x) paste0(ENVS[e],'_',x,'.s_se'))
    
    # merge to additional tmp df
    df.final.tmp1 <- merge(dcast_s,dcast_s_se,by = 'Index', sort= F)
    df.final.tmp2 <- merge(df.final.tmp1, df.tmp[,names(df.tmp) %in% c('Index','Diverse.BC','Environment.BC','Environment','s_bar_w','sd_w','AT','ATz')], sort = FALSE)
    dendro.data <- df.final.tmp2[,names(df.final.tmp2) %in% c('Index','Diverse.BC','Environment.BC','Environment','s_bar_w','sd_w','AT','ATz')]
    dendro.data[,'bfa.env'] <- paste0(ENVS[e])
    
    # only keep unique rows
    s_res_final <- rbind(s_res_final, dendro.data[!duplicated(dendro.data),])
    
    # write parsed data file for producing dendrogram
    write.csv(file = paste0('../data_PLT/data_hBFA2/processed_fitnesses/dendro.data_',ENVS[e],'.csv'), dendro.data)
    
    # write full parsed data file for all rep fitnesses + averaged estimates
    write.csv(file = paste0('../data_PLT/data_hBFA2/processed_fitnesses/df_s_all_',ENVS[e],'.csv'), df_s.e6)
  }
  # clean up environment:
  rm(s_files)
}

# final files to use will be:
# 1. s_res_final
# 2. JDFE after applying do.call('cbind', JDFE)

# use this for PCplot
JDFE <- dcast(s_res_final, formula = Environment + Index ~ bfa.env, value.var = 's_bar_w')
write.csv(file = paste0('../data_PLT/data_hBFA2/processed_fitnesses/JDFE_all.csv'), JDFE)
write.csv(file = paste0('../data_PLT/data_hBFA2/processed_fitnesses/df_s_all_full.csv'), s_res_final)

```"
