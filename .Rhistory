n_bcs = length(clust_ids[clust_ids == clust])) ->
df_tmp
df_full <-
dplyr::bind_rows(df_tmp)
}
}
write_out <- function(df, base_name = NULL, out_dir = NULL, str_to_append = NULL) {
stopifnot(!is.null(out_dir) & !is.null(str_to_append))
if (!dir.exists(out_dir)) {
dir.create(file.path(out_dir))
}
if (is.null(base_name)) {
base_name = "output_"
} else {
base_name %>%
strsplit("\\.csv") %>%
unlist() %>%
dplyr::first() ->
base_name
}
outpath <- file.path(out_dir, paste0(base_name, str_to_append, ".csv"))
readr::write_csv(df, path = outpath, col_names = T)
}
# ------------------------- #
# main def                  #
# ------------------------- #
main <- function(arguments) {
# check + grab input files
if (sum(!sapply(arguments$infiles, file.exists)) > 0 ) {
stop("One or more infile does not exist. Please check infile path and try again.",
call. = FALSE)
}
# read infiles
infile <- read.table(arguments$infile,
sep = ",",
header = T,
stringsAsFactors = F)
# grab barcodes to retain after filtering:
adapted_df <-
infile %>%
dplyr::filter(Subpool.Environment != "not_read") %>%
filter_to_focal_bcs(
retain_neutrals = FALSE,
retain_adapteds = TRUE,
retain_autodips = FALSE
)
neutral_df <-
infile %>%
filter_to_focal_bcs(
retain_neutrals = TRUE,
retain_adapteds = FALSE,
retain_autodips = FALSE
)
# find tree depth of neutrals with mahalanobis distance:
neutral_df %>%
prep_fit_matrix(means_only = FALSE,
excludes = arguments$exclude,
iva_s = arguments$use_iva,
gens = arguments$gens) ->
neutral_df_matr
neutral_df_matr$means %>%
get_neutral_tree_depth(quant = 0.95) ->
neutral_clust_height
neutral_df_matr$means %>%
get_neutral_cov_matr() ->
neutral_cov
# use neutral tree depth to define initial clusters for each environment; pass as arg
adapted_df %>%
split(adapted_df$Subpool.Environment) ->
adapted_by_env
adapted_df_w_clust <- list()
for (env in seq_along(adapted_by_env)) {
cat(sprintf("\nWorking on env %s...\n", names(adapted_by_env)[env]))
adapted_by_env[[env]] %>%
prep_fit_matrix(means_only = FALSE,
excludes = arguments$exclude,
iva_s = arguments$use_iva,
gens = arguments$gens) ->
matr_prepped
matr_prepped$means %>%
get_clusters_by_cut(cut_at = neutral_clust_height) ->
clusts_initial
clusts_initial$cluster %>%
reduce_clusters_by_dist(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clusts_final
clusts_final %>%
average_clusters(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clust_wise_mean
adapted_by_env[[env]] %>%
dplyr::left_join(clusts_final, by = "Full.BC") ->
adapted_df_w_clust[[env]]
}
adapted_df_w_clust_full <- do.call(rbind, adapted_df_w_clust)
clust_wise_means_full   <- do.call(rbind, clust_wise_means)
adapted_df_w_clust_full %>%
write_out(out_dir = arguments$outdir,
base_name = basename(arguments$infile),
str_to_append = "_w_clusts")
clust_wise_means_full %>%
write_out(out_dir = arguments$outdir,
base_name = basename(arguments$infile),
str_to_append = "w_clust_means")
}
# ------------------------- #
# main                      #
# ------------------------- #
"cluster_lineages.R
Usage:
cluster_lineages.R [--help]
cluster_lineages.R [options] <infile>
Options:
-h --help                     Show this screen.
-o --outdir=<outdir>          Output directory [default: ./]
-u --use_iva                  Flag to determine whether to use inverse variance weighted avg or arithmentic avg [default: TRUE]
-g --gens=<gens>              Number of generations per cycle (used to divide input fitness estimates) [default: 8]
-e --exclude=<env>...         Space-separated list of environments to exclude from neutral set calculations
Arguments:
infile                        Input file(s) containing fitness calls for BFA run.
" -> doc
# define default args for debug_status == TRUE
arguments <- list(
use_iva = TRUE,
infile = "data/fitness_data/fitness_calls/hBFA1_cutoff-5_adapteds_autodips.csv",
outdir = "data/fitness_data/fitness_calls",
gens = "8",
exclude = "X48Hr"
)
debug_status <- TRUE
arguments <- run_args_parse(arguments, debug_status)
cat("\n**********************\n")
cat("* cluster_lineages.R *\n")
cat("************************\n\n")
main(arguments)
cat("**Script completed successfully!**\n\n")
if (is.data.frame(clusters) & "cluster" %in% names(clusters)) {
clust_ids <- clusters$cluster
} else {
clust_ids <- clusters
}
df_full <- data.frame()
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
clust
clust_mean
clust = 1
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
clust_mean
maha_mean <- function(x, x_var, covm) {
if (all(is.vector(x), is.vector(x_var))) {
sigma_hat <- covm
diag(sigma_hat) <- x_var
return(list(mean = x,
covm = sigma_hat))
}
for (i in seq_along(nrow(x))) {
sigma_i <- covm
diag(sigma_i) <- x_var[i, ]
sigma_i_inv <- solve(sigma_i)
maha_x <- sigma_i_inv %*% x[i, ]
if (i == 1) {
sigma_hat_inv <- sigma_i_inv
maha_x_tot <- maha_x
} else {
sigma_hat_inv <- sigma_hat_inv + sigma_i_inv
maha_x_tot <- maha_x_tot + maha_x
}
sigma_hat <- solve(sigma_hat_inv)
maha_mean_vec <- sigma_hat %*% maha_x_tot
}
return(list(mean = as.vector(maha_mean_vec),
covm = sigma_hat))
}
clust
clust <- 2
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
clust_mean
maha_mean <- function(x, x_var, covm) {
if (all(is.vector(x), is.vector(x_var))) {
sigma_hat <- covm
diag(sigma_hat) <- x_var
return(list(mean = x,
covm = sigma_hat))
}
for (i in seq_along(nrow(x))) {
sigma_i <- covm
diag(sigma_i) <- x_var[i, ]
sigma_i_inv <- solve(sigma_i)
maha_x <- sigma_i_inv %*% x[i, ]
if (i == 1) {
sigma_hat_inv <- sigma_i_inv
maha_x_tot <- maha_x
} else {
sigma_hat_inv <- sigma_hat_inv + sigma_i_inv
maha_x_tot <- maha_x_tot + maha_x
}
sigma_hat <- solve(sigma_hat_inv)
maha_mean_vec <- t(sigma_hat %*% maha_x_tot)
}
return(list(mean = maha_mean_vec,
covm = sigma_hat))
}
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
clust_mean
clust_mean$mean
as.atomic(clust_mean$mean)
atomic(clust_mean$mean)
c(clust_mean$mean)
as.vector(clust_mean$mean)
(clust_mean$mean)
names(clust_mean$mean)
as.matrix(clust_mean$mean)
colnames(clust_mean$mean)
clust = 1
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
clust_mean
str(clust_mean$mean)
is.vector(clust_mean)
is.matrix(clust_mean)
clust = 2
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
is.matrix(clust_mean)
is.vector(clust_mean)
is.vector(clust_mean$mean)
is.matrix(clust_mean$mean)
(clust_mean$mean)
c(clust_mean$mean)
c(clust_mean$mean) -> tmp
attr(tmp)
attr(tmp, names = colnames(clust_mean$mean))
names(tmp) = colnames(clust_mean$mean)
tmp
maha_mean <- function(x, x_var, covm) {
if (all(is.vector(x), is.vector(x_var))) {
sigma_hat <- covm
diag(sigma_hat) <- x_var
return(list(mean = x,
covm = sigma_hat))
}
for (i in seq_along(nrow(x))) {
sigma_i <- covm
diag(sigma_i) <- x_var[i, ]
sigma_i_inv <- solve(sigma_i)
maha_x <- sigma_i_inv %*% x[i, ]
if (i == 1) {
sigma_hat_inv <- sigma_i_inv
maha_x_tot <- maha_x
} else {
sigma_hat_inv <- sigma_hat_inv + sigma_i_inv
maha_x_tot <- maha_x_tot + maha_x
}
sigma_hat <- solve(sigma_hat_inv)
maha_mean_vec <- sigma_hat %*% maha_x_tot
maha_mean_vec2 <- c(maha_mean_vec)
names(maha_mean_vec2) <- row.names(maha_mean_vec)
maha_mean_vec <- maha_mean_vec2
}
return(list(mean = maha_mean_vec,
covm = sigma_hat))
}
clust
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
clust_mean
names(clust_mean$mean) %>%
sapply(function(x) {
x %>%
strsplit("\\.") %>%
unlist() %>%
dplyr::first()
}) -> envs
envs
data.frame(bfa_env = names(clust_mean$mean),
s = clust_mean$mean,
s_se = sqrt(diag(clust_mean$covm)),
cluster = clust,
n_bcs = length(clust_ids[clust_ids == clust])) ->
df_tmp
df_full <-
dplyr::bind_rows(df_tmp)
df_full
names(clust_mean$mean) %>%
sapply(function(x) {
x %>%
strsplit("\\.") %>%
unlist() %>%
dplyr::first()
}) -> envs
envs
envs
names(clust_mean$mean)
names(clust_mean$mean) <- envs
names(clust_mean$mean)
data.frame(bfa_env = names(clust_mean$mean),
s = clust_mean$mean,
s_se = sqrt(diag(clust_mean$covm)),
cluster = clust,
n_bcs = length(clust_ids[clust_ids == clust])) ->
df_tmp
df_full <-
dplyr::bind_rows(df_tmp)
df_full
df_full <- data.frame()
for (clust in seq_along(unique(clust_ids))) {
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
names(clust_mean$mean) %>%
sapply(function(x) {
x %>%
strsplit("\\.") %>%
unlist() %>%
dplyr::first()
}) -> envs
names(clust_mean$mean) <- envs
data.frame(bfa_env = names(clust_mean$mean),
s = clust_mean$mean,
s_se = sqrt(diag(clust_mean$covm)),
cluster = clust,
n_bcs = length(clust_ids[clust_ids == clust])) ->
df_tmp
df_full <-
dplyr::bind_rows(df_full, df_tmp)
}
df_full
average_clusters <- function(clusters, mean_matr, var_matr, covm) {
if (is.data.frame(clusters) & "cluster" %in% names(clusters)) {
clust_ids <- clusters$cluster
} else {
clust_ids <- clusters
}
df_full <- data.frame()
for (clust in seq_along(unique(clust_ids))) {
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
names(clust_mean$mean) %>%
sapply(function(x) {
x %>%
strsplit("\\.") %>%
unlist() %>%
dplyr::first()
}) -> envs
names(clust_mean$mean) <- envs
data.frame(bfa_env = names(clust_mean$mean),
s = clust_mean$mean,
s_se = sqrt(diag(clust_mean$covm)),
cluster = clust,
n_bcs = length(clust_ids[clust_ids == clust])) ->
df_tmp
df_full <-
dplyr::bind_rows(df_full, df_tmp)
}
return(df_full)
}
names(adapted_by_env)
env
names(adapted_by_env)[env]
clusts_final %>%
average_clusters(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clust_wise_mean
clust_wise_mean
clust_wise_mean$source <- names(adapted_by_env)[env]
clust_wise_mean
average_clusters <- function(clusters, mean_matr, var_matr, covm) {
if (is.data.frame(clusters) & "cluster" %in% names(clusters)) {
clust_ids <- clusters$cluster
} else {
clust_ids <- clusters
}
df_full <- data.frame()
for (clust in seq_along(unique(clust_ids))) {
clust_mean <- maha_mean(x = mean_matr[clust_ids == clust, ],
x_var = var_matr[clust_ids == clust, ],
covm = covm)
names(clust_mean$mean) %>%
sapply(function(x) {
x %>%
strsplit("\\.") %>%
unlist() %>%
dplyr::first()
}) -> envs
names(clust_mean$mean) <- envs
data.frame(bfa_env = names(clust_mean$mean),
s = clust_mean$mean,
s_se = sqrt(diag(clust_mean$covm)),
cluster = clust,
n_bcs = length(clust_ids[clust_ids == clust])) ->
df_tmp
df_full %>%
dplyr::bind_rows(df_tmp) ->
df_full
}
return(df_full)
}
env <- 1
clusters_averaged <- list()
env <- 1
cat(sprintf("\nWorking on env %s...\n", names(adapted_by_env)[env]))
adapted_by_env[[env]] %>%
prep_fit_matrix(means_only = FALSE,
excludes = arguments$exclude,
iva_s = arguments$use_iva,
gens = arguments$gens) ->
matr_prepped
matr_prepped$means %>%
get_clusters_by_cut(cut_at = neutral_clust_height) ->
clusts_initial
clusts_initial$cluster %>%
reduce_clusters_by_dist(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clusts_final
adapted_by_env[[env]] %>%
dplyr::left_join(clusts_final, by = "Full.BC") ->
adapted_df_w_clust[[env]]
clusts_final %>%
average_clusters(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clust_wise_mean
clust_wise_mean
clust_wise_mean$source <- names(adapted_by_env)[env]
clust_wise_mean
clusters_averaged[[env]] <- clust_wise_mean
adapted_df_w_clust <- list()
clust_wise_means <- list()
for (env in seq_along(adapted_by_env)) {
cat(sprintf("\nWorking on env %s...\n", names(adapted_by_env)[env]))
adapted_by_env[[env]] %>%
prep_fit_matrix(means_only = FALSE,
excludes = arguments$exclude,
iva_s = arguments$use_iva,
gens = arguments$gens) ->
matr_prepped
matr_prepped$means %>%
get_clusters_by_cut(cut_at = neutral_clust_height) ->
clusts_initial
clusts_initial$cluster %>%
reduce_clusters_by_dist(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clusts_final
adapted_by_env[[env]] %>%
dplyr::left_join(clusts_final, by = "Full.BC") ->
adapted_df_w_clust[[env]]
clusts_final %>%
average_clusters(mean_matr = matr_prepped$means,
var_matr = matr_prepped$sigmas^2,
covm = neutral_cov) ->
clust_wise_mean
clust_wise_mean$source <- names(adapted_by_env)[env]
clust_wise_means[[env]] <- clust_wise_mean
}
adapted_df_w_clust_full <- do.call(rbind, adapted_df_w_clust)
clust_wise_means_full   <- do.call(rbind, clust_wise_means)
adapted_df_w_clust_full
clust_wise_means_full
clust_wise_means_full %>%
write_out(out_dir = arguments$outdir,
base_name = basename(arguments$infile),
str_to_append = "w_clust_means")
cat("\n*********************\n")
cat("* tabulate_by_env.R *\n")
cat("***********************\n\n")
cat("\n*********************\n")
cat("* tabulate_by_env.R *\n")
cat("**********************\n\n")
cat("\n*************************\n")
cat("* filter_autodiploids.R *\n")
cat("*************************\n\n")
cat("\n**********************\n")
cat("* cluster_lineages.R *\n")
cat("**********************\n\n")
write_out <- function(df, base_name = NULL, out_dir = NULL, str_to_append = NULL) {
stopifnot(!is.null(out_dir) & !is.null(str_to_append))
if (!dir.exists(out_dir)) {
dir.create(file.path(out_dir))
}
if (is.null(base_name)) {
base_name = "output_"
} else {
base_name %>%
strsplit("_adapted") %>%
unlist() %>%
dplyr::first() ->
base_name
}
outpath <- file.path(out_dir, paste0(base_name, str_to_append, ".csv"))
readr::write_csv(df, path = outpath, col_names = T)
}
View(OpenRead)
View(OpenRead)
View(OpenRead)
View(OpenRead)
