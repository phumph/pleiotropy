facet_grid(Subpool.Environment ~ wgs, scales = 'free_y') +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.4) +
ylab('s per gen')
# generate fitness clusters:
x <- adapteds
head(x)
x %>%
dplyr::filter(is_adapted == TRUE) %>%
dplyr::select(the_cols, wgs)
x %>%
dplyr::filter(is_adapted == TRUE) %>%
dplyr::select(the_cols, wgs) %>% names()
# generate fitness clusters:
x <- adapteds
the_cols <- focal_cols[!focal_cols %in% c('Diverse.BC',
'Environment.BC',
'maha_dist',
'dist_pval',
'is_adapted',
'neutral_set',
'Which.Subpools',
grep('_err$', focal_cols, value = T),
grep(arguments$exclude, focal_cols, value = T))]
x <-
x %>%
dplyr::filter(is_adapted == TRUE) %>%
dplyr::select(the_cols, wgs) %>%
dplyr::mutate(CLM.iva_s = CLM.iva_s / 10,
FLC4.iva_s = FLC4.iva_s / 10) %>%
tidyr::gather(key = 'bfa_env', value = 'fitness', -Full.BC, -Subpool.Environment, -wgs) %>%
dplyr::filter(!Subpool.Environment %in% c('none','not read'))
ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs, scales = 'free_y') +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.4) +
ylab('s per gen')
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black')
print(fit_plot_1)
print(fit_plot_1)
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
print(fit_plot_1)
print(fit_plot_1)
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 0, vjust = 1, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
print(fit_plot_1)
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
print(fit_plot_1)
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
print(fit_plot_1)
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 1, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
print(fit_plot_1)
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
print(fit_plot_1)
packrat::disable(project = NULL)
suppressWarnings(suppressMessages(library(dplyr)))
suppressWarnings(suppressMessages(library(tidyr)))
suppressWarnings(suppressMessages(library(ggplot2)))
suppressWarnings(suppressMessages(library(progress)))
suppressWarnings(suppressMessages(library(docopt)))
run_args_parse <- function(debug_status) {
if (debug_status == TRUE) {
arguments <- list()
arguments$use_iva     <- TRUE
arguments$infile      <- "../data/fitness_data/fitness_estimation/dBFA2_s_03_23_18_GC_cutoff_5.csv"
arguments$outdir     <- "../data/fitness_data/fitness_calls"
arguments$neutral_col <- 'Ancestor_YPD_2N'
arguments$name        <- 'cutoff-5'
arguments$reps_iter   <- 500
arguments$reps_final  <- 1000
arguments$exclude     <- 'CLM|FLC4'
arguments$cutoff      <- 0.01
arguments$gens        <- 8
} else if (debug_status == FALSE) {
arguments <- docopt(doc, version = 'call_adapteds v.1.0')
}
return(arguments)
}
OpenRead <- function(arg) {
if (arg %in% c("-", "/dev/stdin")) {
file("stdin", open = "r")
} else {
file(arg, open = "r")
}
}
prep_fit_matrix <- function(df, is_neutral = TRUE, means_only = FALSE, neutral_col, excludes, iva_s, gens) {
# take input counts file and generate list of 2 matrixes:
# (n x k) matrix of k-variate mean vectors for n barcodes
# (n x k) k-variate sigma vectors for n barcodes
# for debugging:
# excludes <- list(c('CLM'), c('FLC4'), c('Stan'))
# neutral_col <- 'Ancestor_YPD_2N'
# df = bfa_dat
# gens = 8
avg_type <- ifelse(iva_s == TRUE, 'iva_s', 'ave')
focal_cols <- c(grep('\\.BC',   names(df), value = T),
grep('Subpool', names(df), value = T),
grep('\\.R[0-9]', names(df), invert = T, value = T),
grep(paste0(avg_type),  names(df), value = T))
focal_cols <- focal_cols[!grepl(paste0(unlist(excludes), collapse='|'), focal_cols)]
df <- df[ , names(df) %in% focal_cols]
# examine list of neutrals if flag present
if (is_neutral == TRUE) {
if (!is.null(neutral_col)) {
df <-
df %>%
dplyr::filter(Subpool.Environment == neutral_col)
} else {
stop("Please define neutral_col!")
}
}
row.names(df) <- df$Full.BC
df_mat <-
df %>%
dplyr::select(grep('iva_s$|iva_s_err$', names(df), value = T)) %>%
as.matrix()
# now I can remove NA, Inf values:
df_mat[is.infinite(df_mat)] <- NA
df_mat <- df_mat[complete.cases(df_mat), ]
# split into means and sigmas:
if (means_only == FALSE) {
df_list <- list(means  = df_mat[, grep('iva_s$', colnames(df_mat))] / gens,
sigmas = df_mat[, grep('iva_s_err$', colnames(df_mat))] / gens)
return(df_list)
} else if (means_only == TRUE) {
means <- df_mat[, grep('iva_s$', colnames(df_mat))] / gens
return(means)
}
}
filter_neutral_outliers <- function(dfs, reps_iter, cutoff, init_cutoff = 0.05, GENS = 8) {
# for each barcode left out:
# generate predictive distribution by sampling from vector of means and stderrs
# # for debugging:
# dfs <- neut_list
#
means  <- dfs[["means"]]
sigmas <- dfs[["sigmas"]]
# # grab unique barcodes
# bcs <- row.names(means) %>% unique()
#
# find distance of each barcode to mean; sort by desc(distance)
starting_dists <- mahalanobis(means,
colMeans(means),
cov(means))
means <-
means %>%
cbind(starting_dists)
sigmas <-
sigmas %>%
cbind(starting_dists)
means  <- means[order(means[,   'starting_dists'], decreasing = TRUE), ]
sigmas <- sigmas[order(sigmas[, 'starting_dists'], decreasing = TRUE), ]
# determine quick and dirty the set I'm going to evaluate
# all with Chisq p-value of < init_cutoff
init_pvals <- pchisq(means[, 'starting_dists'], df = dim(means)[2] - 1, lower.tail = FALSE)
# grab barcodes with p-values <= init_cutoff:
candidate_outliers <- names(init_pvals[init_pvals <= init_cutoff])
# go through each candidate outlier
# remove it
# generate more robust testing distribution
# flag to remove given p-value
# NEED TO FINISH THIS ROUTINE:
# replace with while loop which progressively eliminates barcodes
# until stopping condition is met
# for (i in seq_along(candidate_outliers)) {
#
#   # remove focal barcode
#   means2  <- means[-i,  grep('starting_dists', colnames(means), invert = TRUE)]
#   sigmas2 <- sigmas[-i, grep('starting_dists', colnames(means), invert = TRUE)]
#   test_bc <- means[i,   grep('starting_dists', colnames(means), invert = TRUE)]
#
#   # generate multivariate normal random variables for each vector:
#   res_mat <- NULL
#
#   # wrap this in a function call
#   for (ii in seq_along(row.names(means2))) {
#     res_mat <- rbind(res_mat, MASS::mvrnorm(n = R, means2[ii, ], diag(sigmas2[ii, ]^2)))
#   }
#
#   # calculate distance of each barcode in set
#   D <- mahalanobis(rbind(test_bc,res_mat),
#                    colMeans(res_mat),
#                    cov(res_mat))
#
#   # generate distance of test barcode
#   D_test <- mahalanobis(test_bc,
#                         colMeans(res_mat),
#                         cov(res_mat))
#
#   # calculate p-value of test_bc dist
#   P_test <- sum(D >= D_test) / length(D)
# }
final_neuts <- row.names(means)[!row.names(means) %in% candidate_outliers]
return(final_neuts)
}
generate_neutral_test_distn <- function(dfs, neutrals, reps_final) {
means  <- dfs[["means"]]
sigmas <- dfs[["sigmas"]]
# subset to neutral list
means2  <-  means[row.names(means) %in% neutrals, ]
sigmas2 <- sigmas[row.names(sigmas) %in% neutrals, ]
# generative model of distribution of k-variate vectors
res_mat <- NULL
for (ii in seq_along(row.names(means2))) {
res_mat <- rbind(res_mat, MASS::mvrnorm(n = reps_final, means2[ii, ], diag(sigmas2[ii, ]^2)))
}
# generate testing distribution of distances to apply to all barcodes
D <- mahalanobis(res_mat,
colMeans(res_mat),
cov(res_mat))
L1 <- list(col_means = colMeans(res_mat),
cov_matr  = cov(res_mat),
distances = D)
return(L1)
}
flag_adapteds <- function(matr, testing_distn, cutoff) {
# takes mean vector of all barcodes, neutral test distn,
# and compares distance of each barcode to the neutral set.
# for now, does not handle missing values but simply excludes them.
# I'll need to update the script to do this soon.
# calculate distance of each barcode versus neutral set:
D <- mahalanobis(matr,
testing_distn$col_means,
testing_distn$cov_matr)
# for each: determine p-value within testing distribution
p_vals <- sapply(D, function(x) sum(testing_distn$distances >= x) / length(testing_distn$distances))
is_adapted <- D > quantile(testing_distn$distances, probs = 1 - cutoff)
return(data.frame(Full.BC = row.names(matr),
matr,
maha_dist = D,
dist_pval = p_vals,
is_adapted))
}
main <- function(bfa_dat, arguments) {
# take bfa_dat
# run it through name conversion
cat("Preparing input file...")
fit_mats <-
bfa_dat %>%
prep_fit_matrix(neutral_col = arguments$neutral_col,
excludes    = arguments$exclude,
iva_s       = arguments$use_iva,
gens        = as.double(arguments$gens),
is_neutral  = TRUE)
cat("Done!\n")
cat("Detecting outliers...")
neutral_set <-
fit_mats %>%
filter_neutral_outliers(reps_iter = as.double(arguments$reps_iter),
cutoff    = as.double(arguments$cutoff))
cat("Done!\n")
# generate testing distribution with refined neutral set
cat("Generating testing distribution for determining adapteds...")
neutral_test_distn <-
fit_mats %>%
generate_neutral_test_distn(neutrals   = neutral_set,
reps_final = as.double(arguments$reps_final))
cat("Done!\n")
cat("Determining adapted barcodes...")
# flag input barcodes as adapted or not based on distance
adapteds <-
bfa_dat %>%
prep_fit_matrix(excludes    = arguments$exclude,
iva_s       = arguments$use_iva,
gens        = as.double(arguments$gens),
is_neutral  = FALSE,
means_only  = TRUE) %>%
flag_adapteds(testing_distn = neutral_test_distn,
cutoff        = as.double(arguments$cutoff))
cat("Done!\n")
# fit_val <- ifelse(arguments$use_iva == TRUE, 'iva_s', 'ave_s')
# fit_err <- ifelse(arguments$use_iva == TRUE, 'iva_s_err', 'ave_err')
#
# fit_cols <- c(grep(paste0(fit_val,'$'), names(bfa_dat), value = T),
#               grep(paste0(fit_err,'$'), names(bfa_dat), value = T))
#
suppressWarnings(
adapteds_df <-
bfa_dat %>%
dplyr::left_join(dplyr::select(adapteds, Full.BC, maha_dist, dist_pval, is_adapted),
by = 'Full.BC')
)
adapteds_df$neutral_set <- FALSE
adapteds_df$neutral_set[adapteds_df$Full.BC %in% neutral_set] <- TRUE
return(adapteds_df)
}
infile   <- OpenRead(arguments$infile)
# run
arguments <- run_args_parse(debug_status == TRUE)
# run
debug_status <- TRUE
arguments <- run_args_parse(debug_status)
infile   <- OpenRead(arguments$infile)
bfa_dat  <- read.table(infile,
header = TRUE,
sep = ',',
stringsAsFactors = F)
# take bfa_dat
# run it through name conversion
cat("Preparing input file...")
fit_mats <-
bfa_dat %>%
prep_fit_matrix(neutral_col = arguments$neutral_col,
excludes    = arguments$exclude,
iva_s       = arguments$use_iva,
gens        = as.double(arguments$gens),
is_neutral  = TRUE)
cat("Done!\n")
cat("Detecting outliers...")
neutral_set <-
fit_mats %>%
filter_neutral_outliers(reps_iter = as.double(arguments$reps_iter),
cutoff    = as.double(arguments$cutoff))
head(neutral_set)
dim(neutral_set)
length(neutral_set)
# generate testing distribution with refined neutral set
cat("Generating testing distribution for determining adapteds...")
neutral_test_distn <-
fit_mats %>%
generate_neutral_test_distn(neutrals   = neutral_set,
reps_final = as.double(arguments$reps_final))
head(neutral_test_distn)
# flag input barcodes as adapted or not based on distance
adapteds <-
bfa_dat %>%
prep_fit_matrix(excludes    = arguments$exclude,
iva_s       = arguments$use_iva,
gens        = as.double(arguments$gens),
is_neutral  = FALSE,
means_only  = TRUE) %>%
flag_adapteds(testing_distn = neutral_test_distn,
cutoff        = as.double(arguments$cutoff))
head(adapteds)
cat("Done!\n")
suppressWarnings(
adapteds_df <-
bfa_dat %>%
dplyr::left_join(dplyr::select(adapteds, Full.BC, maha_dist, dist_pval, is_adapted),
by = 'Full.BC')
)
adapteds_df$neutral_set <- FALSE
adapteds_df$neutral_set[adapteds_df$Full.BC %in% neutral_set] <- TRUE
head(adapteds_df)
?mahalanobis
library(dplyr)
library(tidyr)
library(knitr)
library(ggplot2)
library(ggpubr)
arguments <- list()
arguments$use_iva <- TRUE
arguments$adapteds <- '../data/fitness_data/fitness_calls/cutoff-5_adapteds_2019-11-25.csv'
arguments$variants <- '../data/mutation_data/mutations_by_bc.csv'
arguments$exclude  <- 'Stan'
arguments$gens     <- 8
# bring in adapteds
adapteds <- read.table(file = file.path(arguments$adapteds),
header = T,
sep = ',',
stringsAsFactors = F)
# subset columns to focal_cols
fit_val <- ifelse(arguments$use_iva == TRUE, 'iva_s', 'ave_s')
focal_cols <- c('Full.BC','Diverse.BC','Environment.BC','Subpool.Environment','Which.Subpools',
grep(fit_val, names(adapteds), value = T),
'maha_dist','dist_pval','is_adapted','neutral_set')
adapteds <- adapteds[, names(adapteds) %in% focal_cols]
# bring in variants
variants <- read.table(file = file.path(arguments$variants),
header = T,
sep = ',',
stringsAsFactors = F)
# add flag whether we have WGS data
adapteds$wgs <- FALSE
adapteds$wgs[adapteds$Full.BC %in% variants$Full.BC] <- TRUE
#### PLOTS ####
ttt <- data.frame(table(adapteds$is_adapted,
adapteds$Subpool.Environment)) %>%
dplyr::arrange(desc(Var1),desc(Freq))
# scrub levels that don't make sense; re-order:
ttt <- ttt[!ttt$Var2 %in% c('none','not_read'),]
ttt$Var2 <- factor(ttt$Var2, levels = paste0(unique(ttt$Var2)))
# supply text annotations:
ttt2 <- reshape2::dcast(ttt, Var2 ~ Var1, value.var = 'Freq')
names(ttt2) <- c('source','non_adapted','adapted')
ttt2 <- dplyr::mutate(ttt2,
total = non_adapted + adapted,
perc = round(adapted / (adapted + non_adapted), 2))
clone_counts_2N <- ggplot() +
geom_bar(data = ttt, aes(x = Var2, y = Freq, fill = Var1), stat = 'identity', position = position_dodge(0.5), alpha = 0.5) +
theme_bw() + scale_fill_manual(values = c('gray40','dodgerblue'), name = 'adapted') +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
ylab("n BCs w/fitness") +
xlab("source env") +
annotate(geom = "text", label = paste0(round(ttt2$perc,2)), x = ttt2$source, y = -20, size = 2) +
scale_y_continuous(limits = c(-20,600), breaks = seq(0,600,100))
# now tally up with mutation data:
adapteds_wgs <- adapteds[adapteds$wgs == TRUE, ]
mmm <- data.frame(table(adapteds_wgs$is_adapted,
adapteds_wgs$Subpool.Environment)) %>%
dplyr::arrange(desc(Var1),desc(Freq))
# scrub levels that don't make sense; re-order:
mmm <- mmm[!mmm$Var2 %in% c('none','not_read'),]
mmm$Var2 <- factor(mmm$Var2, levels = paste0(unique(mmm$Var2)))
# supply text annotations:
mmm2 <- reshape2::dcast(mmm, Var2 ~ Var1, value.var = 'Freq')
names(mmm2) <- c('source','non_adapted','adapted')
mmm2 <- dplyr::mutate(mmm2,
total = non_adapted + adapted,
perc = round(adapted / (adapted + non_adapted),2))
wgs_counts_2N <- ggplot() +
geom_bar(data = mmm, aes(x = Var2, y = Freq, fill = Var1), stat = 'identity', position = position_dodge(0.5), alpha = 0.5) +
theme_bw() + scale_fill_manual(values = c('gray40','dodgerblue'), name = 'adapted') +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
ylab("n BCs w/wgs data") +
xlab("source env") +
annotate(geom = "text", label = paste0(round(mmm2$perc,2)), x = mmm2$source, y = -5, size = 2) +
scale_y_continuous(limits = c(-5,120), breaks = seq(0,120,20))
# generate plottable object:
clone_counts_bar1 <- ggarrange(plotlist = list(clone_counts_2N, wgs_counts_2N), labels = c('a','b'),
hjust = 0,
vjust = 1,
align = 'hv',
widths = c(1,0.66), common.legend = T)
# generate fitness clusters:
x <- adapteds
the_cols <- focal_cols[!focal_cols %in% c('Diverse.BC',
'Environment.BC',
'maha_dist',
'dist_pval',
'is_adapted',
'neutral_set',
'Which.Subpools',
grep('_err$', focal_cols, value = T),
grep(arguments$exclude, focal_cols, value = T))]
plot_fitness <- function(x, the_cols) {
x <-
x %>%
dplyr::filter(is_adapted == TRUE) %>%
dplyr::select(the_cols, wgs) %>%
dplyr::mutate(CLM.iva_s = CLM.iva_s / 10,
FLC4.iva_s = FLC4.iva_s / 10) %>%
tidyr::gather(key = 'bfa_env', value = 'fitness', -Full.BC, -Subpool.Environment, -wgs) %>%
dplyr::filter(!Subpool.Environment %in% c('none','not read'))
fit_plot_1 <- ggplot(x, aes(x = bfa_env, y = fitness / as.double(arguments$gens), group = Full.BC, col = Subpool.Environment)) +
facet_grid(Subpool.Environment ~ wgs) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0, size = 6),
legend.position = 'none') +
geom_line(alpha = 0.33) +
ylab('s per gen') +
geom_hline(yintercept = 0, col = 'black') +
scale_y_continuous(limits = c(-0.2,0.1), breaks = seq(-0.2,0.1,0.025))
}
clone_counts_bar1
